{"name":"MemDB","tagline":"Distributed transactional in memory database","body":"## Why memdb?\r\n\r\n- __Performance__ : Data access is mainly based on in process memory, which is extremely fast.\r\n\r\n- __Scalable__ : System is horizontally scalable by adding more shards.\r\n\r\n- __Transaction__ : Full transaction support like traditional database, data consistency is guaranteed. 'row' based locking mechanism is used.\r\n\r\n- __High Availability__ : Each shard is backed by one or more redis replica, you will never lose any commited data.\r\n\r\n__Comparison with other databases__\r\n\r\nDatabase | Performance      | Horizontally Scalable | Transaction Support | Data Structure  \r\n---------|------------------|-----------------------|---------------------|-----------------\r\nMySQL    | Medium (Disk I/O)| No                    | __Yes (InnoDB)__   | Row based       \r\nMongoDB  | Medium (Disk I/O)| __Yes__                   | No  (except some basic atomic modifier) | __Object(BSON)__   \r\nRedis    | __High (Memory)__ | __Yes__                   | No  (.multi can do some 'transaction like' thing) | Very Elemental  \r\n__MemDB__    | __High (Memory)__ | __Yes__                   | __Yes__                 | __Object(JSON)__   \r\n\r\n## Documents\r\n\r\n### [The Wiki](https://github.com/rain1017/memdb/wiki)\r\n\r\n## Quick Start\r\n\r\n### Install Dependencies\r\n\r\n* Install [Node.js v0.12](https://nodejs.org/download/)\r\n\r\n* Install [Redis](http://redis.io/download)\r\n\r\n* Install [MongoDB](https://www.mongodb.org/downloads)\r\n\r\n### A Quick Sample\r\n\r\n```javascript\r\nvar memdb = require('memdb');\r\nvar mdbgoose = memdb.goose;\r\nvar P = require('bluebird');\r\n\r\n// memdb's config\r\nvar config = {\r\n    //shard Id (Must unique and immutable for each shard)\r\n    shard : 's1',\r\n    // Global backend storage, all shards must connect to the same mongodb (or mongodb cluster)\r\n    backend : {engine : 'mongodb', url : 'mongodb://localhost/memdb-test'},\r\n    // Global locking redis, all shards must connect to the same redis (or redis cluster)\r\n    locking : {host : '127.0.0.1', port : 6379, db : 0},\r\n    // Global event redis, all shards must connect to the same redis\r\n    event : {host : '127.0.0.1', port : 6379, db : 0},\r\n    // Data replication redis, one redis instance for each shard\r\n    slave : {host : '127.0.0.1', port : 6379, db : 1},\r\n};\r\n\r\n// Define player schema\r\nvar playerSchema = new mdbgoose.Schema({\r\n    _id : String,\r\n    name : String,\r\n    areaId : {type : Number, index : true, indexIgnore : [-1, null]},\r\n    deviceType : {type : Number, indexIgnore : [-1, null]},\r\n    deviceId : {type : String, indexIgnore : ['', null]},\r\n    items : [mdbgoose.SchemaTypes.Mixed],\r\n}, {collection : 'player'});\r\n// Define a compound unique index\r\nplayerSchema.index({deviceType : 1, deviceId : 1}, {unique : true});\r\n\r\n// Define player model\r\nvar Player = mdbgoose.model('player', playerSchema);\r\n\r\nvar main = P.coroutine(function*(){\r\n    // Parse mdbgoose schema to collection config\r\n    config.collections = mdbgoose.genCollectionConfig();\r\n    // Start a memdb shard with in-process mode\r\n    yield memdb.startServer(config);\r\n\r\n    // Connect to in-process server\r\n    yield mdbgoose.connectAsync();\r\n    // Execute in a transaction\r\n    yield mdbgoose.transactionAsync(P.coroutine(function*(){\r\n        var player = new Player({\r\n            _id : 'p1',\r\n            name: 'rain',\r\n            areaId : 1,\r\n            deviceType : 1,\r\n            deviceId : 'id1',\r\n            items : [],\r\n        });\r\n        // insert a player\r\n        yield player.saveAsync();\r\n        // find player by id\r\n        console.log(yield Player.findAsync('p1'));\r\n        // find player by areaId, return array of players\r\n        console.log(yield Player.findAsync({areaId : 1}));\r\n        // find player by deviceType and deviceId\r\n        player = yield Player.findOneAsync({deviceType : 1, deviceId : 'id1'});\r\n        console.log(player);\r\n\r\n        // update player\r\n        player.areaId = 2;\r\n        yield player.saveAsync();\r\n\r\n        // remove the player\r\n        yield player.removeAsync();\r\n    }));\r\n\r\n    // stop memdb server\r\n    yield memdb.stopServer();\r\n});\r\n\r\nif (require.main === module) {\r\n    main().catch(console.error).finally(process.exit);\r\n}\r\n```\r\n\r\n__Run the sample__\r\n```\r\nnpm install memdb bluebird\r\nnode --harmony sample.js\r\n```\r\n\r\n__Become a cluster__\r\n\r\nJust start more shards that connect to __the same global services (backend/locking/event)__, and they will automatically become a MemDB cluster.\r\n\r\n## Quick-pomelo\r\n__[quick-pomelo](http://quickpomelo.com)__ is a rapid and robust game server framework based on memdb\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}