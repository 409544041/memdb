{"name":"MemDB","tagline":"Distributed transactional in memory database","body":"## Why memdb?\r\n\r\n- __Performance__ : In memory data access which is extremely fast.\r\n\r\n- __Scalable__ : System is horizontally scalable by adding more shards.\r\n\r\n- __Transaction__ : Full transaction support like traditional database, data consistency is guaranteed. 'row' based locking mechanism is used.\r\n\r\n- __Simple__ : Mongodb-like API, very easy to learn if you have a mongodb background.\r\n\r\n__Comparison with other databases__\r\n\r\nDatabase | Performance      | Horizontally Scalable | Transaction Support | Data Structure  \r\n---------|------------------|-----------------------|---------------------|-----------------\r\nMySQL    | Medium (Disk I/O)| No                    | __Yes (InnoDB)__   | Row based       \r\nMongoDB  | Medium (Disk I/O)| __Yes__                   | No  (except some basic atomic modifier) | __Object(BSON)__   \r\nRedis    | __High (Memory)__ | __Yes__                   | No  (.multi can do some 'transaction like' thing) | Very Elemental  \r\n__MemDB__    | __High (Memory)__ | __Yes__                   | __Yes__                 | __Object(JSON)__   \r\n\r\n## Documents\r\n\r\n### [The Wiki](https://github.com/rain1017/memdb/wiki)\r\n\r\n## Quick Start\r\n\r\n### Install Dependencies\r\n\r\n* Install [Node.js >=v0.10](https://nodejs.org/download/)\r\n\r\n* Install [Redis](http://redis.io/download)\r\n\r\n* Install [MongoDB](https://www.mongodb.org/downloads)\r\n\r\n### Install MemDB\r\n\r\n* Install memdb\r\n```\r\nsudo npm install -g memdb-server\r\n```\r\n\r\n### Configure MemDB\r\n\r\nModify settings in `.memdb.js` on your need. Please read comments carefully.\r\n\r\n### Start MemDB\r\n\r\nUse `memdbcluster` to control lifecycle of memdb server cluster\r\n```\r\nmemdbcluster [start | stop | status] [--conf=.memdb.js] [--shard=shardId]\r\n```\r\n\r\n### Play with memdb shell\r\n\r\n```js\r\n$ memdb -h 127.0.0.1 -p 31017 // specify the shard's host and port to connect\r\nMemDB shell\r\nconnected to 127.0.0.1:31017\r\nmemdb> db.insert('player', {_id : 1, name : 'rain'}) // insert a doc to 'player' collection\r\n'1'\r\nmemdb> db.find('player', 1)  // find doc by id\r\n{ _id: '1', name: 'rain' }\r\nmemdb> db.commit() // commit changes\r\ntrue\r\nmemdb> db.update('player', 1, {$set : {name : 'snow'}}) // update doc\r\n1\r\nmemdb> db.find('player', 1, 'name')\r\n{ name: 'snow' }\r\nmemdb> db.rollback() // rollback changes\r\ntrue\r\nmemdb> db.find('player', 1, 'name')\r\n{ name: 'rain' }\r\nmemdb> db.remove('player', 1) // remove doc\r\n1\r\nmemdb> db.commit()\r\ntrue\r\nmemdb> ^D (to exit)\r\n```\r\n\r\n### Nodejs client using AutoConnection\r\n\r\nAutoConnection manages a pool of connections for each shard, execute transaction on specified shard, and auto commit on transaction complete or rollback on failure.\r\n\r\n```js\r\n// To run the sample:\r\n// npm install memdb-client\r\n// run with node >= 0.12 with --harmony option\r\n// We assume you have started shard 's1' on localhost:31017, 's2' on localhost:31018.\r\n\r\nvar memdb = require('memdb-client');\r\nvar P = memdb.Promise; // just bluebird promise\r\n\r\nvar main = P.coroutine(function*(){\r\n    // All database access should via this autoconn object, \r\n    // you can preserve autoconn object in a global module that can be accessed anywhere\r\n    var autoconn = yield memdb.autoConnect({\r\n        shards : { // Specify all shards here\r\n            s1 : {host : '127.0.0.1', port : 31017},\r\n            s2 : {host : '127.0.0.1', port : 31018},\r\n        }\r\n    });\r\n\r\n    var doc = {_id : '1', name : 'rain', level : 1};\r\n\r\n    // Get player collection object\r\n    var Player = autoconn.collection('player');\r\n\r\n    // Make a transaction in shard s1\r\n    yield autoconn.transaction(P.coroutine(function*(){\r\n        // Upsert a doc (update if exist, insert if not exist)\r\n        yield Player.update(doc._id, doc, {upsert : true});\r\n        // Find the doc\r\n        var ret = yield Player.find(doc._id);\r\n        console.log(ret); // {_id : '1', name : 'rain', level : 1}\r\n    }), 's1'); // Auto commit after transaction\r\n\r\n    try{\r\n        // Make another transaction in shard s1\r\n        yield autoconn.transaction(P.coroutine(function*(){\r\n            // Update doc with $set modifier\r\n            yield Player.update(doc._id, {$set : {level : 2}});\r\n            // Find the changed doc with specified field\r\n            var ret = yield Player.find(doc._id, 'level');\r\n            console.log(ret); // {level : 2}\r\n            // Exception here!\r\n            throw new Error('Oops!');\r\n        }), 's1');\r\n    }\r\n    catch(err){ // Catch the exception\r\n        // Change is rolled back\r\n        yield autoconn.transaction(P.coroutine(function*(){\r\n            var ret = yield Player.find(doc._id, 'level');\r\n            console.log(ret); // {level : 1}\r\n        }), 's1');\r\n    }\r\n\r\n    // Make transcation in another shard\r\n    // Since we just accessed this doc in s1, the doc will 'fly' from shard s1 to s2\r\n    // In real production you should avoid these kind of data 'fly' by routing transaction to proper shard\r\n    yield autoconn.transaction(P.coroutine(function*(){\r\n        yield Player.remove(doc._id);\r\n    }), 's2');\r\n\r\n    // Close all connections\r\n    yield autoconn.close();\r\n});\r\n\r\nif (require.main === module) {\r\n    main().finally(process.exit);\r\n}\r\n```\r\n\r\n### Nodejs client using MdbGoose\r\n\r\nMdbgoose is the 'mongoose' for memdb\r\n\r\n```js\r\n// To run the sample:\r\n// npm install memdb-client\r\n// run with node >= 0.12 with --harmony option\r\n// We assume you have started shard 's1' on localhost:31017\r\n\r\nvar memdb = require('memdb-client');\r\nvar P = memdb.Promise;\r\nvar mdbgoose = memdb.goose;\r\n\r\n// Define player schema\r\nvar playerSchema = new mdbgoose.Schema({\r\n    _id : String,\r\n    name : String,\r\n    areaId : Number,\r\n    deviceType : Number,\r\n    deviceId : String,\r\n    items : [mdbgoose.SchemaTypes.Mixed],\r\n}, {collection : 'player'});\r\n// Define player model\r\nvar Player = mdbgoose.model('player', playerSchema);\r\n\r\nvar main = P.coroutine(function*(){\r\n    // Connect to memdb\r\n    yield mdbgoose.connectAsync({\r\n        shards : { // specify all shards here\r\n            s1 : {host : '127.0.0.1', port: 31017},\r\n        }\r\n    });\r\n\r\n    // Make a transaction in s1\r\n    yield mdbgoose.transactionAsync(P.coroutine(function*(){\r\n\r\n        var player = new Player({\r\n            _id : 'p1',\r\n            name: 'rain',\r\n            areaId : 1,\r\n            deviceType : 1,\r\n            deviceId : 'id1',\r\n            items : [],\r\n        });\r\n\r\n        // insert a player\r\n        yield player.saveAsync();\r\n\r\n        // find player by id\r\n        var doc = yield Player.findAsync('p1');\r\n        console.log('%j', doc);\r\n\r\n        // find player by areaId, return array of players\r\n        // (index should be configured in .memdb.js)\r\n        var docs = yield Player.findAsync({areaId : 1});\r\n        console.log('%j', docs);\r\n\r\n        // find player by deviceType and deviceId\r\n        // (index should be configured in .memdb.js)\r\n        player = yield Player.findOneAsync({deviceType : 1, deviceId : 'id1'});\r\n\r\n        // update player\r\n        player.areaId = 2;\r\n        yield player.saveAsync();\r\n\r\n        // remove the player\r\n        yield player.removeAsync();\r\n\r\n    }), 's1');\r\n});\r\n\r\nif (require.main === module) {\r\n    main().finally(process.exit);\r\n}\r\n```\r\n\r\n## Quick-pomelo\r\n__[quick-pomelo](http://quickpomelo.com)__ is a rapid and robust game server framework based on memdb\r\n\r\n\r\n## License\r\n\r\nMemDB - distributed transactional in memory database\r\n\r\nCopyright (C) rain1017\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}